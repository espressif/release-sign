---
name: Sign Windows, macOS files and JARs
description: Sign Windows files (.exe, .dll, .cat, .sys, .msi, .ps1, .jar) using Azure
  Key Vault and Jsign; on macOS runners can also sign and notarize .app, .pkg, .dmg.
author: Espressif Systems
branding:
  icon: lock
  color: blue
inputs:
  path:
    description: Path to file or directory containing files to sign
    required: true
  digest-algorithm:
    description: Digest algorithm to use (SHA-256, SHA-384, SHA-512)
    required: false
    default: SHA-256
  azure-client-id:
    description: Azure Service Principal Client ID
    required: true
  azure-client-secret:
    description: Azure Service Principal Client Secret
    required: true
  azure-tenant-id:
    description: Azure Tenant ID
    required: true
  azure-keyvault-uri:
    description: Azure Key Vault URI
    required: true
  azure-keyvault-cert-name:
    description: Certificate name in Key Vault
    required: true
  azure-keyvault-certchain:
    description: Certificate chain (.p7b) content for JAR signing
    required: false
    default: ''
  jsign-version:
    description: Jsign version to use
    required: false
    default: '7.4'
  macos-signing-identity:
    description: macOS code signing identity (e.g. "Developer ID Application Name
      (TEAM_ID)").
    required: false
    default: ''
  macos-certificate:
    description: Base64-encoded .p12 certificate for macOS code signing.
    required: false
    default: ''
  macos-certificate-pwd:
    description: Password for the macOS .p12 certificate.
    required: false
    default: ''
  macos-entitlements:
    description: Path to entitlements file for codesign (optional, e.g. app.entitlements).
    required: false
    default: ''
  notarization-username:
    description: Apple ID for notarization.
    required: false
    default: ''
  notarization-password:
    description: App-specific password for notarization.
    required: false
    default: ''
  notarization-team-id:
    description: Apple Team ID for notarization.
    required: false
    default: ''
runs:
  using: composite
  steps:
    - name: Set up Java
      uses: actions/setup-java@v4
      with:
        java-version: 17
        distribution: temurin
    - name: Download Jsign (Linux/macOS)
      if: runner.os != 'Windows'
      shell: bash
      run: |
        curl -sL "https://github.com/ebourg/jsign/releases/download/${{ inputs.jsign-version }}/jsign-${{ inputs.jsign-version }}.jar" -o "${{ github.workspace }}/jsign.jar"
        echo "Downloaded Jsign ${{ inputs.jsign-version }}"
    - name: Download Jsign (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        Invoke-WebRequest -Uri "https://github.com/ebourg/jsign/releases/download/${{ inputs.jsign-version }}/jsign-${{ inputs.jsign-version }}.jar" -OutFile "${{ github.workspace }}/jsign.jar"
        Write-Host "Downloaded Jsign ${{ inputs.jsign-version }}"
    - name: Install Azure CLI (Linux)
      if: runner.os == 'Linux'
      shell: bash
      run: |
        if ! command -v az &> /dev/null; then
          curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
        fi
    - name: Install Azure CLI (macOS)
      if: runner.os == 'macOS'
      shell: bash
      run: |
        if ! command -v az &> /dev/null; then
          brew update && brew install azure-cli
        fi
    - name: Install Azure CLI (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        if (-not (Get-Command az -ErrorAction SilentlyContinue)) {
          $ProgressPreference = 'SilentlyContinue'
          Invoke-WebRequest -Uri https://aka.ms/installazurecliwindows -OutFile .\AzureCLI.msi
          Start-Process msiexec.exe -Wait -ArgumentList '/I AzureCLI.msi /quiet'
          Remove-Item .\AzureCLI.msi
        }
    - name: Authenticate to Azure (Linux/macOS)
      if: runner.os != 'Windows'
      shell: bash
      run: |
        az login --service-principal \
          --username "${{ inputs.azure-client-id }}" \
          --password "${{ inputs.azure-client-secret }}" \
          --tenant "${{ inputs.azure-tenant-id }}" \
          --allow-no-subscriptions
        echo "Azure authentication successful"
    - name: Authenticate to Azure (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        az login --service-principal `
          --username "${{ inputs.azure-client-id }}" `
          --password "${{ inputs.azure-client-secret }}" `
          --tenant "${{ inputs.azure-tenant-id }}" `
          --allow-no-subscriptions
        Write-Host "Azure authentication successful"
    - name: Get Azure Key Vault Access Token (Linux/macOS)
      if: runner.os != 'Windows'
      id: get-token-unix
      shell: bash
      run: |
        TOKEN=$(az account get-access-token --resource https://vault.azure.net --query accessToken -o tsv)
        echo "::add-mask::$TOKEN"
        echo "token=$TOKEN" >> $GITHUB_OUTPUT
    - name: Get Azure Key Vault Access Token (Windows)
      if: runner.os == 'Windows'
      id: get-token-windows
      shell: pwsh
      run: |
        $token = az account get-access-token --resource https://vault.azure.net --query accessToken -o tsv
        Write-Host "::add-mask::$token"
        "token=$token" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
    - name: Sign files (Linux/macOS)
      if: runner.os != 'Windows'
      shell: bash
      env:
        AZURE_TOKEN: ${{ steps.get-token-unix.outputs.token }}
        JSIGN_JAR: ${{ github.workspace }}/jsign.jar
        KEYVAULT_URI: ${{ inputs.azure-keyvault-uri }}
        CERT_NAME: ${{ inputs.azure-keyvault-cert-name }}
        DIGEST_ALG: ${{ inputs.digest-algorithm }}
        CERT_CHAIN: ${{ inputs.azure-keyvault-certchain }}
      run: |
        chmod +x "${{ github.action_path }}/scripts/sign-posix.sh"
        "${{ github.action_path }}/scripts/sign-posix.sh" "${{ inputs.path }}"
    - name: Sign and notarize macOS binaries
      if: runner.os == 'macOS' && inputs.macos-signing-identity != '' && inputs.macos-certificate
        != '' && inputs.macos-certificate-pwd != ''
      shell: bash
      env:
        MACOS_SIGNING_IDENTITY: ${{ inputs.macos-signing-identity }}
        MACOS_CERTIFICATE_PWD: ${{ inputs.macos-certificate-pwd }}
        MACOS_ENTITLEMENTS: ${{ inputs.macos-entitlements }}
        NOTARIZATION_USERNAME: ${{ inputs.notarization-username }}
        NOTARIZATION_PASSWORD: ${{ inputs.notarization-password }}
        NOTARIZATION_TEAM_ID: ${{ inputs.notarization-team-id }}
      run: |
        CERT_FILE="${RUNNER_TEMP:-/tmp}/macos-certificate-$$.b64"
        printf '%s' "${{ inputs.macos-certificate }}" > "$CERT_FILE"
        chmod 600 "$CERT_FILE"
        export MACOS_CERTIFICATE_FILE="$CERT_FILE"
        chmod +x "${{ github.action_path }}/scripts/sign-macos.sh"
        "${{ github.action_path }}/scripts/sign-macos.sh" "${{ inputs.path }}"
        rm -f "$CERT_FILE"
    - name: Sign files (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      env:
        AZURE_TOKEN: ${{ steps.get-token-windows.outputs.token }}
        JSIGN_JAR: ${{ github.workspace }}/jsign.jar
        KEYVAULT_URI: ${{ inputs.azure-keyvault-uri }}
        CERT_NAME: ${{ inputs.azure-keyvault-cert-name }}
        DIGEST_ALG: ${{ inputs.digest-algorithm }}
        CERT_CHAIN: ${{ inputs.azure-keyvault-certchain }}
      run: |
        & "${{ github.action_path }}/scripts/sign-windows.ps1" -Path "${{ inputs.path }}"
    - name: Cleanup (Linux/macOS)
      if: always() && runner.os != 'Windows'
      shell: bash
      run: |
        az logout || true
        rm -f "${{ github.workspace }}/jsign.jar" || true
        rm -f "${{ github.workspace }}/certchain.p7b" || true
    - name: Cleanup (Windows)
      if: always() && runner.os == 'Windows'
      shell: pwsh
      run: |-
        az logout 2>$null
        Remove-Item "${{ github.workspace }}/jsign.jar" -ErrorAction SilentlyContinue
        Remove-Item "${{ github.workspace }}/certchain.p7b" -ErrorAction SilentlyContinue
